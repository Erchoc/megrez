# 环境和模块

在笔记[Lua语言中编写模块的基本方法](../模块和包/Lua语言中编写模块的基本方法.md)中我们讨论如何编写模块时，就提到过模块的缺点之一在于**很容易污染全局空间**，例如在私有声明中忘记 `local` 关键字。

环境为解决这个问题提供了一种有趣的方式。一旦模块的主程序块有一个独占的环境，则不仅该模块所有的函数共享了这个环境，该模块的全局变量也进入到了这个环境中。我们可以将所有的公有函数声明为全局变量，这样他们就会自动地进入分开的环境中。模块所要做的就是将这个环境赋值给变量 `_ENV` 。之后，当我们声明函数 `add` 时，它会变成 `M.add` ：

```lua
local M = {}
_ENV = M
function add (c1, c2)
  return new (c1.r, r + c2.r, c1.i + c2.i)
end
```

此外，我们在调用同一模块中的其他函数时不需要任何前缀。在此前的代码中， `add` 会从其环境中得到 `new` ，也就是 `M.new` 。

这种方法为模块提供了一种良好的支持，只需要程序员多做一点额外的工作。使用这种方法，完全不需要前缀，并且调用一个导出的函数与调用一个私有函数没有什么区别。即使程序员忘记了 `local` 关键字，也不会污染全局命名空间。相反，他只是让一个私有变量变成了公有函数而已。

不过尽管如此，**我们在日常中还是倾向于使用原始的基本方法**。也许原始的基本方法需要更多的工作，但代码会更加清晰。为了避免错误地创建全局变量，可以使用 `nil` 赋值给 `_ENV` 的方式。在把 `_ENV` 设为 `nil` 后，任何对全局变量的赋值都会抛出异常。这种方式的另一个好处是无需修改代码也可以在老版本的 `Lua` 语言中运行（在 `Lua5.1` 中，给 `_ENV` 赋值虽然不能阻止出错，但也不会造成问题）。

为了访问其他模块，我们可以使用在之前笔记中讨论过得方法。例如，可以声明一个保存全局环境的局部变量：

```lua
local M = {}
local _G = _G
_ENV = nil
```

然后在全局变量名称前加上 `_G` 和模块名 `M` 即可。

另一种更规范的访问其他模块的做法是只把需要的函数或模块声明为全局变量：

```lua
-- 模块初始化
local M = {}

-- 导入部分：
-- 声明该模块需要的外部函数或模块等
local sqrt = math.sqrt
local io = io

-- 从此以后不能在进行外部访问
_ENV = nil
```

这种方式需要做更多的工作，但是它能清晰地列出模块的依赖。
