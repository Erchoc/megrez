# 瞬表——Ephemeron Table

> [!note|label: 考虑一种情况]
> 一个具有弱引用键的表中的值又引用了对应的键。

这种情况比看上去的更加常见。一个典型的示例是常量函数工厂。这种工厂的参数是一个对象，返回值是一个被调用时返回传入对象的函数：

```lua
function factory (o)
  return (function () return o end)
end
```

这种工厂是实现记忆的一种很好的手段，可以避免在闭包已经存在时又创建新的闭包。接下来展示一种改进方法：

```lua
do
  local mem = {}
  setmetatable(mem, {__mode = "k"})
  function factory (o)
    local res = mem[o]
    if not res then
      res = (function () return o end)
      mem[o] = res
    end
    return res
  end
end  
```

不过，这里另有玄机。请**注意**：表 `mem` 中与一个对象关联的值（常量函数）回指了它自己的键（对象本身）。虽然表中的键是弱引用的，但是表中的值却不是弱引用的。从一个弱引用表的标准理解看，记忆表中没有任何东西会被移除。由于值不是弱引用的，所以对于每一个函数来说都存在一个强引用。每一个函数都指向其对应的对象，因而对于每一个键来说都存在一个强引用。因此，即使有弱引用的键，这些对象也不会被回收。

不过，这种严格的理解不是特别有用。大多数人希望一个表中的值只能通过对应的键来访问。我们可以认为之前的情况是某种环，其中闭包引用了指回闭包（通过记忆表）的对象。

`Lua` 语言通过**瞬表**的概念来解决上述问题。在 `Lua` 语言中，**一个具有弱引用键和强引用的值的表是一个瞬表**。在一个瞬表中，**一个键的可访问性控制着对应值的可访问性**。更确切的说，考虑瞬表中的一个元素 `(k,v)` ，指向 `v` 的引用知道当存在某些指向k的其他外部引用存在时才是强引用，否则，即使 `v` （直接或间接地）引用了 `k` ，垃圾收集器最终会收集 `k` 并把元素从表中移除。

> [!warning|label: 注意]
> 瞬表是 `Lua5.2` 中引入的， `Lua5.1` 依然存在我们描述的问题。
