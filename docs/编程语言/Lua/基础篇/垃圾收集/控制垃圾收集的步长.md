# 控制垃圾收集的步长——Pace

通过函数 `collectgarbage` 可以对垃圾收集器进行一些额外的控制，该函数实际上是几个函数的集合体：第一个参数是一个可选的字符串，用来说明进行何种操作；有些选项使用一个整型作为第二个参数，称为 `data` 。

第一个参数的选项如下所示：

|参数选项|含义|
|-----|-----|
| `stop` |停止垃圾收集，直到使用选项 `restart` 再次调用 `collectgarbage` |
| `restart` |重启垃圾收集器|
| `collect` |执行一次完整的垃圾收集，回收和析构所有不可达的对象。这是**默认**的选项|
| `step` |执行某些垃圾收集工作，第二个参数 `data` 指明工作量，即在分配了 `data` 个字节后垃圾收集器应该做什么|
| `count` |以 `KB` 为单位返回当前已用内存数，该结果是一个**浮点数**，乘以 `1024` 得到的就是精确的**字节数**。该值包括了尚未被回收的死对象|
| `setpause` |设置收集器的 `pause` 参数（**间歇率**）。参数 `data` 以百分比为单位给出要设定的新值：当 `data` 为 `100` 时，参数被设为 `1` （ `100%` ）|
| `setstepmul` |设置收集器的 `stepmul` 参数（**步进倍率**， `step multiplier` ）。参数 `data` 给出新值，也是以**百分比**为单位|

两个参数 `pause` 和 `stepmul` 控制着垃圾收集器的角色。任何垃圾收集器都是使用 `CPU` 时间换内存空间。在极端情况下，垃圾收集器可能根本不会运行。但是，不耗费 `CPU` 时间是以巨大的内存消耗为代价的。在另外一种极端的情况下，收集器可能每进行一次赋值就得到运行一次完整的垃圾收集。程序能够使用尽可能少的内存，但是是以巨大的 `CPU` 消耗为代价的。 `pause` 和 `stepmul` 的默认值正是试图在这两个极端之间找到的对大多数应用来说是足够好的平衡点。不过，在某些情况下，还是值得试着对他们进行优化。

参数 `pause` 用于控制垃圾收集器在一次收集完成后等待多久再开始新的一次收集。当值为**零**时表示 `Lua` 语言在上一次垃圾回收结束后立即开始一次新的收集。当值为 `200%` 时表示在重启垃圾收集器前等待内存使用翻番。如果像使消耗更多的 `CPU` 时间换取更低的内存消耗，那么可以把这个值设的小一点。通常，我们应该把这个值设在 `0` 到 `200%` 之间。

参数 `stepmul` 控制对于每分配 `1KB` 内存，垃圾收集器应该进行多少工作。这个值越高，垃圾收集器使用的增量越小。一个像 `10000000%` 一样巨大的值会让垃圾收集器表现得像一个非增量的垃圾收集器。默认值是 `200%` 。低于 `100%` 的值会让垃圾收集运行的很慢，以至于可能一次收集也完不成。

函数 `collectgarbage` 的另外一些参数用来在垃圾收集器运行时控制它的行为。同样，对于大多数程序员来说，默认值已经足够了，但是对于一些特殊的应用，用手工控制可能更好，游戏就京城需要这种类型的控制。例如，如果我们不想让垃圾收集在某些阶段运行，那么可以通过调用函数 `collectgarbage("stop")` 停止垃圾收集器，然后再调用 `collectgarbage("restart")` 重新启动垃圾收集器。在一些具有周期性休眠阶段的程序中，可以让垃圾收集器停止，然后在程序休眠期间调用 `collectgarbage("step", n)` 。要设置在每一个休眠期间进行多少工作，要么为 `n` 实验性的选择一个恰当的值，要么把 `n` 设成**零**（意为**最小**的步长），然后在一个循环中调用函数 `collectgarbage` 直到休眠结束。
