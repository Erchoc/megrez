# 迭代器和闭包

**迭代器**（ `iterator` ）是一种可以让我们遍历一个集合中所有元素的代码结构。在 `Lua` 语言中，通常使用**函数**表示迭代器：每一次调用函数时，函数会返回集合中的“下一个”元素。一个典型的例子就是 `io.read` ，每次调用该函数时它都会返回标准输入中的下一行，在没有可以读取的行时返回 `nil` 。

所有的迭代器都需要在连续的调用之间保存一些状态，这样才能知道当前迭代所处的位置及如何从当前位置步进到下一位置。对于函数 `io.read` 而言，**C语言**会将状态保存在流的结构体中。对于我们自己的迭代器而言，闭包则为保存状态提供了一种良好的机制。请注意：**一个闭包就是一个可以访问其自身的环境中一个或多个局部变量的函数**。这些变量将连续调用过程中的值并将其保存在闭包中，从而使得闭包能够记住迭代所处的位置。当然，要创建一个新的闭包，我们还必须创建非局部变量。因此，一个闭包结构通常涉及**两个函数**：闭包本身和一个用于创建该闭包及其封装变量的**工厂**（ `factory` ）。

作为示例，让我们来为列表编写一个简单的迭代器。与 `ipairs` 不同的是，该迭代器并不是返回每个元素的索引值而是返回元素的值：

```lua
function values (t)
  local i = 0
  return function () i = i +1; return t[i] end
end
```

在这个例子中， `values` 就是工厂。每当调用这个工厂时，它就会创建一个新的**闭包**（即**迭代器本身**）。这个闭包将它的状态保存在其外部的变量 `t` 和 `i` 中，这两个变量也是由 `values` 创建的。每次调用这个迭代器时，它就从列表 `t` 中返回下一个值。在遍历完最后一个元素后，迭代器返回 `nil` ，表示迭代结束。

我们可以在一个 `while` 循环中使用这个迭代器：

```lua
t = {10, 20, 30}
iter = values(t)                      -- 创建迭代器
while true do
  local element = iter()              -- 调用迭代器
  if element == nil then break end
  print(element)
end
```

不过，使用泛型for更简单。毕竟，泛型for正是为了这种迭代而设计的：

```lua
t = {10, 20, 30}
for element in values(t) do
  print(element)
end
```

**泛型for**为一次迭代循环做了所有的记录工作：它在内部保存了迭代函数，因此不需要变量 `iter` ；它在每次做新的迭代时都会再次调用迭代器，并在迭代器返回 `nil` 时结束循环。
