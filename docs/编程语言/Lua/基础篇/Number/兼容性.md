# 兼容性

诚然， `Lua5.3` 中引入的整型值导致其相比于此前的 `Lua` 版本出现了一定的不兼容，但如前所述，程序员基本上可以忽略整型值和浮点型值之间的不同。当忽略这些不同时，也就忽略掉了 `Lua5.3` 和 `Lua5.2` 之间的不同（至于数值， `Lua5.0` 及 `Lua5.1` 与 `Lua5.2` 完全一致）。

`Lua5.3` 和 `Lua5.2` 之间的最大不同就是整数的表示范围。 `Lua5.2` 支持的最大整数为2^53^，而 `Lua5.3` 支持的最大整数为2^63^。在当做计数值使用时，他们之间的区别通常不会导致问题；然而，当把整型值当做通用的**比特位**使用时（例如，把 `3` 个 `20-bit` 的整型值放在一起使用），他们之间的区别则可能很重要。

虽然 `Lua5.2` 不支持整型，但是在几个场景下仍然会涉及整型的问题。例如， `C` 语言实现的库函数通常使用整型参数，但 `Lua5.2` 却并没有约定这些情况下浮点型值和整型值之间的转换方法：官方文档里只是说“**数值会以某种不确定的方式被截断**”。这个问题非常现实，根据具体的不同平台， `Lua5.2` 可能将 `-3.2` 转换成 `-3` ，也可能转换为 `-4` 。与 `Lua5.2` 不同的是 `Lua5.3` 明确了这种类型转换的规则，即只有数值恰好可以表示为整数时才可以进行转换。

由于 `Lua5.2` 中的数值类型只有一种，所以没有提供函数 `math.type` 。由于 `Lua5.2` 中不存在整型的概念，所以也没有常量 `math.maxinteger` 和 `math.mininteger` 。虽然可以实现，但 `Lua5.2` 中也没有 `floor` 除法（毕竟， `Lua5.2` 中的**取模**运算基本上和 `floor` 除法是等价的）。

可能让人感到震惊的是，与整型引相关的问题的根源在于， `Lua` 语言将数值转换为字符串的方式。 `Lua5.2` 将所有的整数值格式化为整数（不带小数点），而 `Lua5.3` 则将所有的浮点数格式化为浮点型（带有十进制小数点或指数）。因此， `Lua5.2` 会将 `3.0` 格式化为 `"3"` 输出，而 `Lua5.3` 则会将其格式化为 `"3.0"` 输出。虽然 `Lua` 语言从未说明过格式化数值的方式，但是很多程序员默认的是早期版本的格式化输出行为。在将数值转换为字符串时，我们可以通过显示地指明格式的方式来避免这种问题。然而，这个问题实际上提示我们，语言设计思想中可能存在更深层的瑕疵，即无理由的将整数转换为浮点型值来可能并非好事（实际上，这也正是 `Lua5.3` 中引入新格式化规则的主要动机。将整数值使用浮点型表示通常会使得程序可读性不佳，而新的格式化规则避免了这些问题）。
