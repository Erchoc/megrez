# 惯例

我们可以简单的通过增加 `0.0` 的方法将整型值强制转换为浮点型值，**一个整型值总是可以被转换成浮点型值**：

```lua
> -3 + 0.0                      --> -3.0
> 0x7fffffffffffffff + 0.0      --> 9.2233720368548e+18
```

小于2^53^的所有整型值的表示与双精度浮点型值的表示一样，对于绝对值超过这个值的整型值而言，在将其强制转换为浮点型值时可能导致精度损失：

```lua
> 9007199254740991 + 0.0 == 9007199254740991        --> true
> 9007199254740992 + 0.0 == 9007199254740992        --> true
> 9007199254740993 + 0.0 == 9007199254740993        --> false
```

在最后一行中，2^53^ + 1的结果被取整为2^53^，打破了等式，表达式结果为 `false` 。

通过与零进行按位或运算，可以把浮点型值强制转换位整型值：

```lua
> 2^53          --> 9.007199254741e+15  (浮点型值)
> 2^53 | 0      --> 9007199254740992    (整型值)
```

在将浮点型值强制转换位整型值时， `Lua` 语言会检查数值是否与整型值表示完全一致，即没有小数部分且其值在整型值的表示范围内，如果不满足条件则会抛出异常：

```lua
> 3.2 | 0         --小数部分
stdin:1: number has no integer representation
> 2^64 | 0        --超出范围
stdin:1: number has no integer representation
> math.random(1, 3.5)  
stdin:1: bad argument #2 to 'random' (number has no integer representation)   --数值没有用整数表示
```

对小数进行取整**必须**显示地调用取整函数。

另一种把数值强制转换为整型的方式是使用函数 `math.tointeger` ，该函数会在输入参数无法转换为整型值时返回 `nil`

```lua
> math.tointeger(-258.0)    --> -258
> math.tointeger(2^30)      --> 1073741824
> math.tointeger(5.01)      --> nil           (不是整数值)
> math.tointeger(2^64)      --> nil           (超出范围)
```

这个函数在需要检查一个数值能否被转换成整型值时尤为有用。例如，以下函数在可能时会将输入参数转换为整型值，否则保持原来的值不变：

```lua
function cond2int(x)
  return math.tointeger(x) or x
end
```
