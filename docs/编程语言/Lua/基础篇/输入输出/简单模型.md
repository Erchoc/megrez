# 简单 I/O 模型

对于文件操作来说，I/O库提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前输出流，其I/O操作是通过这些流实现的。I/O库把当前输入流初始化为进程的标准输入（C语言的stdin），将当前输出流初始化为进程的标准输出（C语言的stdout）。因此，执行类似于io.read()这样的语句时，就可以从标准输入中读取一行。

函数io.input和函数io.output可以用于改变当前的输入输出流。调用io.input(filename)会以只读模式打开指定文件，并将文件设置为当前输入流。之后，所有的输入都将来自该文件，除非再次调用io.input。对于输出而言，函数io.output的逻辑与之类似。如果出现错误，这两个函数都会抛出异常。如果想直接处理这些异常，则必须使用完整I/O模型。

由于函数write比函数read简单，我们首先来看函数write。函数io.write可以去读任意数量的字符串（或者数字）并将其写入当前输出流。由于调用该函数时可以使用过个参数，因此应该避免使用io.write(a..b..c)，应该调用io.write(a, b, c)，后者可以用更少的资源达到同样的效果，并且可以避免更多的连接动作。

作为原则，应该只在"用后即弃"的代码或调试代码中使用函数print；当需要完整控制输出时，应该使用函数io.write。与函数print不同，函数io.write不会在最终的输出结果中添加诸如制表符或换行符这样的额外内容。此外，函数io.write允许对输出进行重定向，而函数print只能使用标准输出。最后，函数print可以自动为其参数调用tostring，这一点对于调试而言非常便利。但这也容易导致一些诡异的bug。

函数io.write在将数值转换为字符串时遵循一般的转换规则：如果想要完全地控制这种转换，则应该使用函数string.format:

```lua
> io.write("sint(3) = ", math.sin(3), "\n")                   --> sint(3) = 0.14112000805987
> io.write(string.format("sin(3) = %.4f\n", math.sin(3)))     --> sin(3) = 0.1411
```

函数io.read可以从当前输入流中读取字符串，其参数决定了要读取的数据：

|参数|含义|
|-----|-----|
|"a"|读取整个文件|
|"l"|读取下一行（丢弃换行符）|
|"L"|读取下一行（保留换行符）|
|"n"|读取一个数值|
|num|以字符串读取num个字符|

> [!tip|label: 提示]
> 在Lua5.2及更早的版本中，所有字符串选项之前要有一个星号。出于兼容性考虑，Lua5.3也可以支持星号。

调用io.read("a")可以从当前位置开始读取当前输入文件的全部内容。如果当前位置处于文件的末尾或文件为空，那么该函数返回一个空字符串。

因为Lua语言可以高效的处理长字符串，所以在Lua语言中编写过滤器的一种简单技巧就是将整个文件读取到一个字符串中，然后对字符串进行处理。最后输出结果为：

```lua
t = io.read("a")                        -- 读取整个文件
t = string.gsub(t, "bad", "good")       -- 进行处理
io.write(t)                             -- 输出结果
```
