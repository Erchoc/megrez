# 简单 I/O 模型

对于文件操作来说， `I/O` 库提供了两种不同的模型。简单模型虚拟了一个**当前输入流**和一个**当前输出流**，其 `I/O` 操作是通过这些流实现的。 `I/O` 库把当前输入流初始化为进程的**标准输入**（ `C` 语言的 `stdin` ），将当前输出流初始化为进程的**标准输出**（ `C` 语言的 `stdout` ）。因此，执行类似于 `io.read()` 这样的语句时，就可以从标准输入中读取一行。

函数 `io.input` 和函数 `io.output` 可以用于改变当前的输入输出流。调用 `io.input(filename)` 会以**只读模式**打开指定文件，并将文件设置为**当前输入流**。之后，所有的输入都将来自该文件，除非再次调用 `io.input` 。对于输出而言，函数 `io.output` 的逻辑与之类似。如果出现错误，这两个函数都会抛出异常。如果想直接处理这些异常，则必须使用完整 `I/O` 模型。

## io.write

由于函数 `write` 比函数 `read` 简单，我们首先来看函数 `write` 。函数 `io.write` 可以去读任意数量的字符串（或者数字）并将其写入当前输出流。由于调用该函数时可以使用过个参数，因此应该避免使用 `io.write(a..b..c)` ，应该调用 `io.write(a, b, c)` ，后者可以用更少的资源达到同样的效果，并且可以避免更多的连接动作。

作为原则，应该只在"**用后即弃**"的代码或调试代码中使用函数 `print` ；当需要完整控制输出时，应该使用函数 `io.write` 。与函数 `print` 不同，函数 `io.write` 不会在最终的输出结果中添加诸如制表符或换行符这样的额外内容。此外，函数 `io.write` 允许对输出进行**重定向**，而函数 `print` 只能使用标准输出。最后，函数 `print` 可以**自动**为其参数调用 `tostring` ，这一点对于调试而言非常便利。但这也容易导致一些**诡异**的 `bug` 。

函数 `io.write` 在将数值转换为字符串时遵循一般的转换规则：如果想要完全地控制这种转换，则应该使用函数 `string.format` :

```lua
> io.write("sint(3) = ", math.sin(3), "\n")                   --> sint(3) = 0.14112000805987
> io.write(string.format("sin(3) = %.4f\n", math.sin(3)))     --> sin(3) = 0.1411
```

## io.read

函数 `io.read` 可以从当前输入流中读取字符串，其参数决定了要读取的数据：

|参数|含义|
|-----|-----|
| `"a"` |读取整个文件|
| `"l"` |读取下一行（丢弃换行符）|
| `"L"` |读取下一行（保留换行符）|
| `"n"` |读取一个数值|
| `num` |以字符串读取 `num` 个字符|

> [!tip|label: 提示]
> 在 `Lua5.2` 及更早的版本中，所有字符串选项之前要有一个**星号**。出于兼容性考虑， `Lua5.3` 也可以支持星号。

调用 `io.read("a")` 可以从当前位置开始读取当前输入文件的全部内容。如果当前位置处于文件的末尾或文件为空，那么该函数返回一个空字符串。

因为 `Lua` 语言可以高效的处理长字符串，所以在 `Lua` 语言中编写过滤器的一种简单技巧就是将整个文件读取到一个字符串中，然后对字符串进行处理。最后输出结果为：

```lua
t = io.read("a")                        -- 读取整个文件
t = string.gsub(t, "bad", "good")       -- 进行处理
io.write(t)                             -- 输出结果
```

举一个更加具体的例子，以下是一段将某个文件的内容使用 `MIME` **可打印字符引用编码**进行编码的代码。这种编码方式将所有非 `ASCII` 字符编码为 `=xx` ，其中 `xx` 是这个字符的**十六进制**。为保证编码的一致性，等号也会被编码：

```lua
t = io.read("all")
t = string.gsub(t, "([\128-\255=])", function (c)
      return string.format("=%02X", string.byte(c))
    end)
io.write(t)
```

函数 `string.gsub` 会匹配所有的等号及非 `ASCII` 字符（从 `128` 到 `255` ），并调用指定的函数完成替换。

调用 `io.read("l")` 会返回当前输入流的下一行，不包括换行符在内；调用 `io.read("L")` 与之类似，但会保留换行符（如果文件存在）。当达到文件末尾时，由于已经没有内容可以返回，该函数会返回 `nil` 。选项 `"l"` 是函数 `read` 的**默认参数**。一般只在逐行处理数据的算法中使用该函数，其他情况则更倾向于使用选项 `"a"` 一次性地读取整个文件，或者**按块读取**。

作为面向行的输入的一个简单例子，以下的程序会在将当前输入复制到当前输出中的同时对每行进行编号：

```lua
for count = 1, math.huge do
  local line = io.read("L")
  if line == nil then break end
  io.write(string.format("%6d  ", count), line)
end
```

## io.lines

不过，如果要逐行迭代一个文件，那么使用 `io.lines` 迭代器会更简单：

```lua
local count = 0
for line in io.lines() do
  count = count + 1
  io.write(string.format("%6d  ", count), line, "\n")
end
```

另一个面向行的输入例子如下所示，其中给出了一个对文件中的行进行排序的完整程序：

```lua
local lines = {}

-- 将所有行读取列表'lines'中
for line in io.lines() do
  lines[#lines + 1] = line
end

-- 排序
table.sort(lines)

-- 输出所有的行
for _, l in ipairs(lines) do
  io.write(l, "\n")
end
```

调用 `io.read("n")` 会从当前输入流中读取一个数值，这也是函数 `read` 返回值为数值（整型或者浮点型，与Lua语法扫描器的规则一致）而非字符串的唯一情况。如果在跳过了空格后，函数 `io.read` 仍然不能从当前位置读取到数值（由于错误的格式问题或到了文件末尾），则返回 `nil` 。

除了上述这些基本的读取模式外，在调用函数 `read` 时还可以用一个数字 `n` 作为其参数：在这种情况下，函数 `read` 会从输入流中读取 `n` 个字符。如果无法读取到任何字符（处于文件末尾）则返回 `nil` ；否则，返回一个由流中最多 `n` 个字符组成的字符串。作为这种读取模式的示例，以下的代码展示了将文件从 `stdin` 复制到 `stdout` 的高效方法：

```lua
while true do
  local block = io.read(2^13)
  if not block then break end
  io.write(block)
end
```

`io.read(0)` 是一个特例，它常用于测试是否到达了文件末尾。如果仍然有数据可供读取，它会返回一个**空字符串**；否则，则返回 `nil` 。

调用函数 `read` 时可以指定多个选项，函数会根据每个参数返回相应的结果。假设有一个每行由 `3` 个数字组成的文件：

6.0     -3.23     15e12
4.3     234       1000001
...

如果像打印每一行的最大值，那么可以通过调用函数 `read` 来一次性地同时读取每行中的 `3` 个数字：

```lua
while true do
  local n1, n2, n3 = io.read("n", "n", "n")
  if not n1 then break end
  print(math.max(n1, n2, n3))
end
```
