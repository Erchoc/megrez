# 简单 I/O 模型

对于文件操作来说，I/O库提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前输出流，其I/O操作是通过这些流实现的。I/O库把当前输入流初始化为进程的标准输入（C语言的stdin），将当前输出流初始化为进程的标准输出（C语言的stdout）。因此，执行类似于io.read()这样的语句时，就可以从标准输入中读取一行。

函数io.input和函数io.output可以用于改变当前的输入输出流。调用io.input(filename)会以只读模式打开指定文件，并将文件设置为当前输入流。之后，所有的输入都将来自该文件，除非再次调用io.input。对于输出而言，函数io.output的逻辑与之类似。如果出现错误，这两个函数都会抛出异常。如果想直接处理这些异常，则必须使用完整I/O模型。

由于函数write比函数read简单，我们首先来看函数write。函数io.write可以去读任意数量的字符串（或者数字）并将其写入当前输出流。由于调用该函数时可以使用过个参数，因此应该避免使用io.write(a..b..c)，应该调用io.write(a, b, c)，后者可以用更少的资源达到同样的效果，并且可以避免更多的连接动作。

作为原则，应该只在"用后即弃"的代码或调试代码中使用函数print；当需要完整控制输出时，应该使用函数io.write。与函数print不同，函数io.write不会在最终的输出结果中添加诸如制表符或换行符这样的额外内容。此外，函数io.write允许对输出进行重定向，而函数print只能使用标准输出。最后，函数print可以自动为其参数调用tostring，这一点对于调试而言非常便利。但这也容易导致一些诡异的bug。
