# `i386` vs `AMD64`

在 `Linux` 系统中，软件包经常分为 `i386` 和 `AMD64` 两种架构， `AMD64` 很容易理解，这个总所皆知，我们电脑都是 `64` 位的，因为 `64` 位处理器是 `AMD` 发明的，所以冠以 `AMD64` 的名号。

> [!tip|label: 提示]
> 到目前为止，大家的电脑处理器大部分都是 `Intel` 的，也是 `64` 位的，可能有人感觉 `64` 位是 `Intel` 发明的，这是不对的。或者有人可能感觉，我的电脑是 `Intel` 的处理器，能用 `AMD64` 架构的软件吗？当然可以了， `Intel` 的 `64` 位授权可是从 `AMD` 哪里拿到的哦！ `Intel` 自己的 `64` 位技术很落后，已经被淘汰了。

`i386=Intel 80386` 。其实 `i386` 通常被用来作为对 `Intel（英特尔）32位微处理器` 的统称。

`AMD64` ，又称 `x86-64` 或 `x64` ，是一种 `64位元` 的电脑处理器架构。它是建基于现有 `32位元` 的 `x86` 架构，由 `AMD` 公司所开发。

> [!tip|label: 提示]
> 以下内容太干燥了，看看得了

`x86` 架构首度出现在 `1978` 年推出的 `Intel 8086` 中央处理器，它是从 `Intel 8008` 处理器中发展而来的，而 `8008` 则是发展自 `Intel 4004` 的。 `Intel` 之后又推出了包括 `80186` 、 `80286` 、 `80386` 以及 `80486` 。 在设计上，这些后续的处理器使用的指令集都是在 `8086` 的基础上添加新支持的指令进行改进的，因此可以说都是**向下兼容**的，即能再 `8086` 上运行的程序在 `80486` 上也一定能运行。由于都是以 `86` 结尾（不过 `8088` 也是 `x86` ），所以把这一系列的指令 集 称之为 `x86` 指令集（架构）。准确的来讲， `x86` 这一术语并不是指的某一个（具体CPU使用的）具体的指令集，而是在 `8086` （的指令集）基础上发展而来 的所有指令集的泛称。

实际上，在 `80486` 以后 `Intel` 推出的绝大多数 `CPU` 都是 `x86` 的，包括 `Pentium` 、 `Pentium Pro` 、 `Pentium MMX` ， `Pentium 2` ，还有后面的 `Pentium 3` 、 `Pentium 4` 、 `Pentium D` 、 `Core 全系列` ， `(x86系列的) Xeon` 。另外，使用 `x86` 架构的处理器制造商远非 `Intel` 一家，最著名的就是 `AMD` ，其他的还有 `VIA` ， `Cyrix` 。可以说， `x86` 架构就是 `桌面级CPU` 的**标准**，你能买到的品牌或者组装的PC，几乎没有不是 `x86 CPU` 的。不过虽说都是 `x86` 的，但只能说明使用的指令集是兼容 `8086` 的，除 `8086` 指令集之外的其他指令支持情况就不一样；其内部实现的微体系结构 `microarchitecture` 显然也是各自不同，就好比 `Linux` 和 `Unix` 虽然都是 `POSIX` 兼容的 `OS` ，都有 `fork` 这个系统调用，但是这个调 用的实现确实各不相同。

从 `1985` 年 `80386` 开始， `intel` 通过对 `x86` 架构进行 `32位` 的扩展，实现了 `32位CPU` ，而之前的都是 `16位` 。 `Intel` 把支持 `32位` 的 `x86` 指令集架构命名为 `ia-32` (Intel Architecture 32bit)。实际上由于 `32` 位 `x86` 处理器的统治性，术语 `x86` 几乎等于 `IA-32` ，即 `32` 位的 `x86` 或 `x86-32` ，例如 `Windows` 和 `Linux` 发行版的 `32` 位命名都是 `x86` （而不是 `x86-32` 或 `ia-32` ）。后来的 `x86-64` 名称也继续强化了这种约定方式。这里还是要强调 `x86` 是一系列架构的泛称，支持 `16` 位、 `32` 位和 `64` 位的指令都有。

该来的还是会来，在 `1999` 年， `AMD` 宣布了 `x86-64` 架构。其实 现方式与之前的 `80386` 思路一致，继续对 `IA-32` 扩展，增加 `64` 位通用寄存器、证书预算单元和逻辑操作，支持 `64` 位虚地址；向前兼容 `ia-32` 。 `2003` 年第一款 `x86-64` 处理器发布， `AMD Operon` 。同时 `AMD` 也将 `x86-64` 正式命名为 `AMD64` 。这 `下Intel` 彻底 `2B` 了（原因后面说），以前都是 `AMD` 小弟追随者 `Intel` 大哥的脚步，如今 `AMD` 先实现了 `64` 位民用桌面级 `CPU` 。其实 `Intel` 也有其 `64` 位计划，在 `2004` 年的 `IDF` 上， `Intel` 承认其 `64` 位计划，命名为 `ia-32e` ，即 `ia-32 extension` ，之后又改成 `EM64T` ， `Extended Memory 64 Technology` ，最终命名为 `Intel64` 。 实际上 `EM64T` 与 `AMD64` 几乎相同。早期 `EM64T` 不兼容 `AMD64` 的少量指令，但是由于 `AMD` 在 `64` 位技术中的领先地位， `Intel2005` 年不得 不宣布将完全兼容 `AMD64` 。所以现在装的 `64` 位版本操作系统从没有说是面向 `Intel` 还是 `AMD` 的。不过在称谓上，大多数厂商还是使用 `x86-64` （ `x86_64` ，或者就是 `x64` ）来称呼此架构，从而保持中立。

`i386` 和 `i486` 作为 `Intel 80386` 和 `80486` 处理器的别名是比较显然的。由于不能使用数字作为注册商标，而且也需要一个正式的名称命名，从 `586` 开始就变为 `Pentium` 了， 这时候 `i586` 就作为了最原始 `Pentium` 的微处理架构 `“P5”` 的别名，同样的 `i686` 对 `P6` ( `Pentium Pro` 使用)， `i786` 对应 `P68` ，或 `NetBurst` 架构。
在我看来，在软件包的命名上使用 `“i某86”` 时应该是说适用于使用这一代微架构的 `CPU` 。但微架构是硬件上事，因此还是在说明适用对应 `CPU` 使用的指令集。比如， `i386` 对应 `IA-32` ，并且由于兼容性肯定适用于 `i486~i686` ； `i686` 不仅适用 `Pentium Pro` ，也适用 `K7` 架构的 `Athlon` 。

前文提到 `Intel` 在 `AMD` 推出民用 `64` 位技术后很被动。其实 `Intel` 也有 `64` 位 `x86 CPU` 的计划，但是由于对于这个市场的不重视，认为需求不足，一直不见面世。而在对 `64` 位需求更加强劲的企业服务器和高性能计算市场上， `1994` 年 `HP` 就 和 `Intel` 合作开始开发一款与 `x86` 架构完全没关系的全新的 `IA-64` 架构。显然 `IA-64` 不兼容 `x86-64` 更别说 `IA32` ， `IA64` 天生就是 `64` 位，基于**显式并行指令运算**（ `EPIC` ）。 `2001` 年第一款 `IA-64` 架构的处理器 `Itanium` 安腾发布。可见， `IA-64` 跟 `IA-32` 在实现上没有什么关系，跟 `x86-64` 也是完全并行的两种 架构， `x86` 架构的 `Intel` 的 `Xeon` 就是 `Intel Itanium` 的竞争对手之一。后来 `Intel` 把 `IA-64` 也干脆改称为 `Intel Itanium` 架构。
